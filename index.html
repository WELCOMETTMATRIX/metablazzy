<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Immersive 3D Dashboard</title>
  <style>
    body { 
      margin: 0; 
      overflow: hidden; 
      background: #0a0a1a;
      touch-action: none;
    }
    #info {
      position: absolute;
      top: 10px;
      left: 10px;
      color: #ffffff;
      font-family: 'Inter', -apple-system, sans-serif;
      font-size: 14px;
      background: rgba(0, 0, 0, 0.7);
      padding: 8px 12px;
      border-radius: 6px;
      user-select: none;
      z-index: 10;
    }
    canvas {
      display: block;
    }
    #mobile-controls {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: none;
      z-index: 20;
    }
    .control-button {
      background: rgba(255, 255, 255, 0.2);
      border: none;
      border-radius: 50%;
      width: 60px;
      height: 60px;
      margin: 0 10px;
      color: white;
      font-size: 24px;
      cursor: pointer;
      touch-action: manipulation;
      transition: background 0.2s;
    }
    .control-button:active {
      background: rgba(255, 255, 255, 0.4);
    }
    @media (max-width: 768px) {
      #mobile-controls {
        display: flex;
      }
      #info {
        font-size: 12px;
      }
    }
  </style>
</head>
<body>
  <div id="info">Desktop: WASD: Move • Mouse: Look • Click: Interact<br>Mobile: Buttons: Forward/Backward • Move Phone: Strafe • Tilt: Look • Tap: Interact</div>
  <div id="mobile-controls">
    <button class="control-button" id="move-forward">↑</button>
    <button class="control-button" id="move-backward">↓</button>
  </div>
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
  </script>
  <script type="module">
    import * as THREE from 'three';
    import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { CSS3DRenderer, CSS3DObject } from 'three/addons/renderers/CSS3DRenderer.js';

    class SceneManager {
      constructor() {
        this.scene = new THREE.Scene();
        this.camera = null;
        this.renderer = null;
        this.cssRenderer = null;
        this.controls = null;
        this.move = { forward: false, backward: false, left: false, right: false };
        this.moveSpeed = 0.1; // Matches A-Frame snippet
        this.clock = new THREE.Clock();
        this.raycaster = new THREE.Raycaster();
        this.isMobile = /Android|iPhone|iPad/i.test(navigator.userAgent);
        this.zoomedObject = null;
        this.originalCameraPos = new THREE.Vector3();
        this.tiltDirection = null; // For mobile strafing via motion
        this.init();
      }

      init() {
        this.setupScene();
        this.setupCamera();
        this.setupRenderers();
        this.setupControls();
        this.setupEnvironment();
        this.setupModels();
        this.setupWebViews();
        this.setupLighting();
        this.setupEventListeners();
        this.animate();
      }

      setupScene() {
        try {
          this.scene.background = new THREE.Color(0x0a0a1a);
          this.scene.fog = new THREE.FogExp2(0x0a0a1a, 0.015);
        } catch (error) {
          console.error('Scene setup failed:', error);
        }
      }

      setupCamera() {
        try {
          this.camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
          );
          this.camera.position.set(0, 1.6, 8);
        } catch (error) {
          console.error('Camera setup failed:', error);
        }
      }

      setupRenderers() {
        try {
          this.renderer = new THREE.WebGLRenderer({ 
            antialias: true, 
            powerPreference: 'high-performance',
            alpha: true 
          });
          this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
          this.renderer.setSize(window.innerWidth, window.innerHeight);
          this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
          this.renderer.toneMappingExposure = 1.0;
          document.body.appendChild(this.renderer.domElement);

          this.cssRenderer = new CSS3DRenderer();
          this.cssRenderer.setSize(window.innerWidth, window.innerHeight);
          this.cssRenderer.domElement.style.position = 'absolute';
          this.cssRenderer.domElement.style.top = '0';
          document.body.appendChild(this.cssRenderer.domElement);
        } catch (error) {
          console.error('Renderer setup failed:', error);
        }
      }

      setupControls() {
        try {
          this.controls = new PointerLockControls(this.camera, this.renderer.domElement);
          this.controls.addEventListener('lock', () => {
            document.getElementById('info').style.opacity = '0.3';
          });
          this.controls.addEventListener('unlock', () => {
            document.getElementById('info').style.opacity = '1';
          });
          this.scene.add(this.controls.getObject());
        } catch (error) {
          console.error('Controls setup failed:', error);
        }
      }

      setupEnvironment() {
        try {
          const floor = new THREE.Mesh(
            new THREE.PlaneGeometry(40, 40),
            new THREE.MeshStandardMaterial({ 
              color: 0x1c2526, 
              roughness: 0.3, 
              metalness: 0.6 
            })
          );
          floor.rotation.x = -Math.PI / 2;
          floor.receiveShadow = true;
          this.scene.add(floor);

          const ceiling = new THREE.Mesh(
            new THREE.SphereGeometry(20, 32, 32, 0, Math.PI * 2, 0, Math.PI / 2),
            new THREE.MeshStandardMaterial({ 
              color: 0x3a3a4a, 
              roughness: 0.5, 
              metalness: 0.4, 
              transparent: true, 
              opacity: 0.7, 
              side: THREE.DoubleSide 
            })
          );
          ceiling.position.set(0, 8, 0);
          ceiling.rotation.x = Math.PI;
          this.scene.add(ceiling);

          const starCount = 200; // Reduced for performance
          const starGeometry = new THREE.BufferGeometry();
          const starPositions = new Float32Array(starCount * 3);
          for (let i = 0; i < starCount * 3; i++) {
            starPositions[i] = (Math.random() - 0.5) * 150;
          }
          starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
          const starMaterial = new THREE.PointsMaterial({ 
            color: 0xaaaaaa, 
            size: 0.05,
            transparent: true,
            opacity: 0.8
          });
          const stars = new THREE.Points(starGeometry, starMaterial);
          stars.position.y = 15;
          this.scene.add(stars);
        } catch (error) {
          console.error('Environment setup failed:', error);
        }
      }

      setupModels() {
        try {
          const loader = new GLTFLoader();
          const models = [
            {
              url: 'https://threejs.org/examples/models/gltf/DamagedHelmet/glTF/DamagedHelmet.gltf',
              position: [5, 0, -10],
              scale: [1.5, 1.5, 1.5],
              rotation: [0, Math.PI / 4, 0]
            },
            {
              url: 'https://threejs.org/examples/models/gltf/LeePerrySmith/LeePerrySmith.gltf',
              position: [-5, 3, -5],
              scale: [0.8, 0.8, 0.8],
              animate: (model) => {
                model.position.y = 3 + Math.sin(Date.now() * 0.001) * 0.2;
              }
            },
            {
              url: 'https://threejs.org/examples/models/gltf/CesiumMan/glTF/CesiumMan.gltf',
              position: [-8, 0, 0],
              scale: [1.2, 1.2, 1.2],
              rotation: [0, -Math.PI / 6, 0]
            }
          ];

          models.forEach(({ url, position, scale, rotation, animate }) => {
            loader.load(
              url,
              (gltf) => {
                const model = gltf.scene;
                model.position.set(...position);
                model.scale.set(...scale);
                if (rotation) model.rotation.set(...rotation);
                model.traverse(child => {
                  if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                  }
                });
                this.scene.add(model);
                if (animate) {
                  const animateModel = () => {
                    animate(model);
                    requestAnimationFrame(animateModel);
                  };
                  animateModel();
                }
              },
              undefined,
              (error) => console.error(`Error loading ${url}:`, error)
            );
          });
        } catch (error) {
          console.error('Models setup failed:', error);
        }
      }

      setupWebViews() {
        try {
          const createIframe = (src, style = {}) => {
            const iframe = document.createElement('iframe');
            iframe.src = src;
            Object.assign(iframe.style, {
              width: '800px',
              height: '600px',
              border: '0',
              borderRadius: '16px',
              boxShadow: '0 0 20px rgba(0,255,255,0.3)',
              ...style
            });
            return iframe;
          };

          this.webViews = [
            {
              iframe: createIframe('https://dexscreener.com/cronos/0x5F028F49a7443f34aeDFc19ED986c92243d98EF5?embed=1&loadChartSettings=0&chartLeftToolbar=0&chartTheme=dark&theme=dark&chartStyle=0&chartType=usd&interval=15'),
              position: [-12, 2.7, -12],
              rotation: [0, 0.3, 0],
              scale: 0.007,
              originalScale: 0.007
            },
            {
              iframe: createIframe('https://gopluslabs.io/token-security/25/0x9ef3fc220867f6cf5655db3d950cda67a3a92f9f', {
                boxShadow: '0 0 20px rgba(0,255,100,0.25)'
              }),
              position: [0, 2.7, -15],
              rotation: [0, 0, 0],
              scale: 0.007,
              originalScale: 0.007
            },
            {
              iframe: createIframe('https://v0-fork-of-matrix-quantum-terminal-g0jxgv.vercel.app/', {
                boxShadow: '0 0 30px rgba(0,255,150,0.7)'
              }),
              position: [12, 2.7, -12],
              rotation: [0, -0.3, 0],
              scale: 0.007,
              originalScale: 0.007
            },
            {
              iframe: createIframe('https://v0-the-orb-sigma.vercel.app/', {
                boxShadow: '0 0 30px rgba(100,100,255,0.7)'
              }),
              position: [-6, 4.5, -14],
              rotation: [0, 0.15, 0],
              scale: 0.007,
              originalScale: 0.007
            },
            {
              iframe: createIframe('https://www.dextools.io/widget-chart/en/cronos/pe-light/0x5f028f49a7443f34aedfc19ed986c92243d98ef5?theme=light&chartType=2&chartResolution=30&drawingToolbars=false'),
              position: [6, 4.5, -14],
              rotation: [0, -0.15, 0],
              scale: 0.007,
              originalScale: 0.007
            }
          ];

          this.webViewObjects = this.webViews.map(({ iframe, position, rotation, scale }) => {
            const cssObject = new CSS3DObject(iframe);
            cssObject.position.set(...position);
            cssObject.rotation.set(...rotation);
            cssObject.scale.set(scale, scale, scale);
            this.scene.add(cssObject);
            return cssObject;
          });
        } catch (error) {
          console.error('Web views setup failed:', error);
        }
      }

      setupLighting() {
        try {
          const ambientLight = new THREE.AmbientLight(0x606060, 0.8);
          this.scene.add(ambientLight);

          const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
          directionalLight.position.set(10, 10, 10);
          directionalLight.castShadow = true;
          directionalLight.shadow.mapSize.set(1024, 1024);
          this.scene.add(directionalLight);
        } catch (error) {
          console.error('Lighting setup failed:', error);
        }
      }

      zoomToWebView(cssObject) {
        try {
          if (this.zoomedObject === cssObject) {
            this.resetZoom();
            return;
          }

          this.originalCameraPos.copy(this.camera.position);
          const targetPos = cssObject.position.clone();
          targetPos.z += 2;
          targetPos.y = cssObject.position.y;

          this.controls.enabled = false;
          this.zoomedObject = cssObject;

          cssObject.scale.setScalar(cssObject.scale.x * 1.5);

          const duration = 500;
          const startTime = Date.now();
          const startPos = this.camera.position.clone();
          
          const animateZoom = () => {
            const elapsed = Date.now() - startTime;
            const t = Math.min(elapsed / duration, 1);
            
            this.camera.position.lerpVectors(startPos, targetPos, t);
            
            if (t < 1) {
              requestAnimationFrame(animateZoom);
            } else {
              cssObject.element.style.pointerEvents = 'auto';
            }
          };
          
          animateZoom();
        } catch (error) {
          console.error('Zoom to web view failed:', error);
        }
      }

      resetZoom() {
        try {
          if (!this.zoomedObject) return;

          const duration = 500;
          const startTime = Date.now();
          const startPos = this.camera.position.clone();
          const cssObject = this.zoomedObject;

          cssObject.element.style.pointerEvents = 'none';
          cssObject.scale.setScalar(cssObject.scale.x / 1.5);

          const animateReset = () => {
            const elapsed = Date.now() - startTime;
            const t = Math.min(elapsed / duration, 1);
            
            this.camera.position.lerpVectors(startPos, this.originalCameraPos, t);
            
            if (t < 1) {
              requestAnimationFrame(animateReset);
            } else {
              this.controls.enabled = true;
              this.zoomedObject = null;
            }
          };
          
          animateReset();
        } catch (error) {
          console.error('Reset zoom failed:', error);
        }
      }

      moveCamera(direction) {
        try {
          const position = this.camera.position;
          switch (direction) {
            case 'up':
              this.camera.position.set(position.x, position.y, position.z - this.moveSpeed);
              break;
            case 'down':
              this.camera.position.set(position.x, position.y, position.z + this.moveSpeed);
              break;
            case 'left':
              this.camera.position.set(position.x - this.moveSpeed, position.y, position.z);
              break;
            case 'right':
              this.camera.position.set(position.x + this.moveSpeed, position.y, position.z);
              break;
          }
        } catch (error) {
          console.error('Move camera failed:', error);
        }
      }

      setupEventListeners() {
        try {
          document.addEventListener('click', (event) => {
            if (this.isMobile || this.zoomedObject) return;
            
            this.controls.lock();
            
            this.raycaster.setFromCamera(new THREE.Vector2(0, 0), this.camera);
            const intersects = this.raycaster.intersectObjects(this.webViewObjects || []);
            
            if (intersects.length > 0) {
              this.zoomToWebView(intersects[0].object);
            }
          });

          if (this.isMobile) {
            document.addEventListener('touchstart', (event) => {
              if (event.target.classList.contains('control-button')) return;
              
              if (this.zoomedObject) {
                this.resetZoom();
                return;
              }
              
              const touch = event.touches[0];
              this.raycaster.setFromCamera(new THREE.Vector2(
                (touch.clientX / window.innerWidth) * 2 - 1,
                -(touch.clientY / window.innerHeight) * 2 + 1
              ), this.camera);
              
              const intersects = this.raycaster.intersectObjects(this.webViewObjects || []);
              
              if (intersects.length > 0) {
                this.zoomToWebView(intersects[0].object);
              }
            });

            // Mobile controls for forward/backward
            const forwardButton = document.getElementById('move-forward');
            const backwardButton = document.getElementById('move-backward');
            if (forwardButton && backwardButton) {
              forwardButton.addEventListener('touchstart', (e) => {
                e.preventDefault();
                this.move.forward = true;
              });
              forwardButton.addEventListener('touchend', (e) => {
                e.preventDefault();
                this.move.forward = false;
              });
              backwardButton.addEventListener('touchstart', (e) => {
                e.preventDefault();
                this.move.backward = true;
              });
              backwardButton.addEventListener('touchend', (e) => {
                e.preventDefault();
                this.move.backward = false;
              });
            }

            // Device orientation for looking
            if (window.DeviceOrientationEvent && typeof DeviceOrientationEvent.requestPermission === 'function') {
              document.addEventListener('touchstart', () => {
                DeviceOrientationEvent.requestPermission()
                  .then(response => {
                    if (response === 'granted') {
                      this.setupDeviceOrientation();
                    }
                  })
                  .catch(error => console.error('Device orientation permission failed:', error));
                // Also request motion permission
                if (typeof DeviceMotionEvent.requestPermission === 'function') {
                  DeviceMotionEvent.requestPermission()
                    .then(response => {
                      if (response === 'granted') {
                        this.setupDeviceMotion();
                      }
                    })
                    .catch(error => console.error('Device motion permission failed:', error));
                } else {
                  this.setupDeviceMotion();
                }
              }, { once: true });
            } else if (window.DeviceOrientationEvent) {
              this.setupDeviceOrientation();
              if (window.DeviceMotionEvent) {
                this.setupDeviceMotion();
              }
            }
          } else {
            document.addEventListener('keydown', (event) => {
              switch (event.code) {
                case 'KeyW': this.move.forward = true; break;
                case 'KeyS': this.move.backward = true; break;
                case 'KeyA': this.move.left = true; break;
                case 'KeyD': this.move.right = true; break;
                case 'Escape': this.resetZoom(); break;
              }
            });

            document.addEventListener('keyup', (event) => {
              switch (event.code) {
                case 'KeyW': this.move.forward = false; break;
                case 'KeyS': this.move.backward = false; break;
                case 'KeyA': this.move.left = false; break;
                case 'KeyD': this.move.right = false; break;
              }
            });
          }

          window.addEventListener('resize', () => {
            try {
              this.camera.aspect = window.innerWidth / window.innerHeight;
              this.camera.updateProjectionMatrix();
              this.renderer.setSize(window.innerWidth, window.innerHeight);
              this.cssRenderer.setSize(window.innerWidth, window.innerHeight);
            } catch (error) {
              console.error('Resize handler failed:', error);
            }
          });
        } catch (error) {
          console.error('Event listeners setup failed:', error);
        }
      }

      setupDeviceOrientation() {
        try {
          window.addEventListener('deviceorientation', (event) => {
            if (this.zoomedObject) return;
            
            const gamma = event.gamma * (Math.PI / 180); // Left-right tilt
            const beta = event.beta * (Math.PI / 180);  // Front-back tilt
            
            // Look around (yaw and pitch)
            this.camera.rotation.y = -gamma * 0.5;
            this.camera.rotation.x = Math.max(-Math.PI/4, Math.min(Math.PI/4, beta * 0.5 - Math.PI/6));
          });
        } catch (error) {
          console.error('Device orientation setup failed:', error);
        }
      }

      setupDeviceMotion() {
        try {
          window.addEventListener('devicemotion', (event) => {
            if (this.zoomedObject) return;
            
            const acceleration = event.accelerationIncludingGravity;
            if (!acceleration) return;
            
            // Use x-axis acceleration for left/right strafing
            const accelX = acceleration.x || 0; // Positive: phone moves right, Negative: phone moves left
            const motionThreshold = 2; // m/s² threshold to avoid noise
            if (Math.abs(accelX) > motionThreshold) {
              this.tiltDirection = accelX > 0 ? 'right' : 'left';
            } else {
              this.tiltDirection = null;
            }
          });
        } catch (error) {
          console.error('Device motion setup failed:', error);
        }
      }

      animate() {
        try {
          requestAnimationFrame(() => this.animate());
          const delta = this.clock.getDelta();

          if (!this.zoomedObject) {
            // Handle forward/backward movement from buttons
            if (this.move.forward) {
              this.moveCamera('up');
            }
            if (this.move.backward) {
              this.moveCamera('down');
            }

            // Handle side-to-side movement from motion on mobile
            if (this.isMobile && this.tiltDirection) {
              this.moveCamera(this.tiltDirection);
            }

            // Handle side-to-side movement from keys on desktop
            if (!this.isMobile) {
              if (this.move.left) {
                this.moveCamera('left');
              }
              if (this.move.right) {
                this.moveCamera('right');
              }
            }
          }

          if (this.renderer && this.cssRenderer) {
            this.renderer.render(this.scene, this.camera);
            this.cssRenderer.render(this.scene, this.camera);
          }
        } catch (error) {
          console.error('Animation loop failed:', error);
        }
      }
    }

    try {
      new SceneManager();
    } catch (error) {
      console.error('SceneManager initialization failed:', error);
    }
  </script>
</body>
</html>
